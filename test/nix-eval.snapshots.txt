# empty
""
==>
undefined

# whitespace
" \t\n"
==>
undefined

# null
"null"
==>
null

# bool
"true"
==>
true

# bool
"false"
==>
false

# int
"1"
==>
1

# float
"1.0"
==>
1.0

# int + float -> float
"1+1.0"
==>
2.0

# float precision
"0.1+0.2"
==>
0.3

# float precision
"0.123456789"
==>
0.123457

# neg
"-1"
==>
-1

# add
"1+1"
==>
2

# sub
"1-1"
==>
0

# empty set
"{}"
==>
{}

# empty rec set
"rec {}"
==>
{}

# set
"{a=1;}"
==>
{"a":1}

# rec set
"rec {a=1;}"
==>
{"a":1}

# rec set
"rec {a=1;b=a;}"
==>
{"a":1,"b":1}

# set error
"{a=1;b=a;}"
==>
ERROR EvalError undefined variable 'a'

# set select
"{a=1;}.a"
==>
1

# set select nested
"{a={b=2;};}.a.b"
==>
2

# set select key error
"{a=1;}.z"
==>
ERROR EvalError attribute 'z' missing

# rec set select
"rec {a=1;b=a;}.b"
==>
1

# let
"let a=1; in a"
==>
1

# let nested
"let a={b=2;}; in a.b"
==>
2

# set update
"{a=0;b=2;}//{a=1;c=3;}"
==>
{"a":1,"b":2,"c":3}

# call null
"null 2"
==>
ERROR EvalError attempt to call something which is not a function but null

# call bool true
"true 2"
==>
ERROR EvalError attempt to call something which is not a function but a Boolean

# call bool false
"false 2"
==>
ERROR EvalError attempt to call something which is not a function but a Boolean

# call list
"[] 2"
==>
ERROR EvalError attempt to call something which is not a function but a list

# call set
"{} 2"
==>
ERROR EvalError attempt to call something which is not a function but a set

# call string 1
"\"\" 2"
==>
ERROR EvalError attempt to call something which is not a function but a string

# SKIP call string 2
"'''' 2"
==>
ERROR EvalError attempt to call something which is not a function but a string

# call integer
"1 2"
==>
ERROR EvalError attempt to call something which is not a function but an integer

# call float
"1.1 2"
==>
ERROR EvalError attempt to call something which is not a function but a float

# call primop add
"__add 1 2"
==>
3

# call primop sub
"__sub 1 2"
==>
-1

# call primop mul
"__mul 1 2"
==>
2

# call primop div int int
"__div 1 2"
==>
0

# call primop div float int
"__div 1.0 2"
==>
0.5

# call primop div int float
"__div 1 2.0"
==>
0.5

# empty list
"[]"
==>
[]

# list
"[ 1 2 ]"
==>
[1,2]

# call primop head
"__head [ 1 2 ]"
==>
1

# call primop head empty
"__head [ ]"
==>
ERROR EvalError list index 0 is out of bounds

# call primop tail
"__tail [ 1 2 ]"
==>
2

# call primop tail empty
"__tail [ ]"
==>
ERROR EvalError 'tail' called on an empty list

# call primop elemAt
"__elemAt [ 1 2 ] 0"
==>
1

# call primop elemAt error 1
"__elemAt [ 1 2 ] (-1)"
==>
ERROR EvalError list index -1 is out of bounds

# call primop elemAt error 2
"__elemAt [ 1 2 ] 2"
==>
ERROR EvalError list index 2 is out of bounds

# list concat
"[1 2]++[3 4]"
==>
[1,2,3,4]

# list concat: empty
"[]++[]"
==>
[]

# list concat: right empty
"[1 2]++[]"
==>
[1,2]

# list concat: left empty
"[]++[3 4]"
==>
[3,4]

# add mul
"2+3*4"
==>
14

# parens add mul
"(2+3)*4"
==>
20

# path not div
"1/2"
==>
"/home/user/1/2"

# call not div
"1 /2"
==>
ERROR EvalError attempt to call something which is not a function but an integer

# div int int
"1/ 2"
==>
0

# div float int
"1.0/ 2"
==>
0.5

# typeof int
"__typeOf 1"
==>
"int"

# typeof float
"__typeOf 1.0"
==>
"float"

# typeof true
"__typeOf true"
==>
"bool"

# typeof false
"__typeOf false"
==>
"bool"

# typeof null
"__typeOf null"
==>
"null"

# typeof list
"__typeOf []"
==>
"list"

# typeof set
"__typeOf {}"
==>
"set"

# typeof string 1
"__typeOf \"\""
==>
"string"

# SKIP typeof string 2
"__typeOf ''''"
==>
"string"

# syntax error ~
"~"
==>
ERROR SyntaxError unexpected invalid token

# eval error undefined variable
"x"
==>
ERROR EvalError undefined variable 'x'

# neg bool
"!true"
==>
false

# neg neg bool
"!!true"
==>
true

# equal
"1==1"
==>
true

# not equal
"1!=2"
==>
true

# if
"if (!true) then 1 else 2"
==>
2

# lambda
"x: x"
==>
Â«lambda @ (string):1:1Â»

# call lambda
"(x: x) 1"
==>
1

# call lambda
"(x: y: x + y) 1 2"
==>
3

# let lambda call
"let f=x: 2*x; in f 3"
==>
6

# let lambda call nested
"let f = a: b: (a+b); in f 1 2"
==>
3

# lambda multi arg
"let f = x: y: z: x; in f 1 2 3"
==>
1

# lambda recursive call
"let f = x: if x > 0 then f (x - 1) else x; in f 1"
==>
0

# lambda nested call
"let f = x: y: (g 1 x) + y; g = x: y: x + y; in f 1 1"
==>
3

# fibonacci 0
"let f = i: n: m: if i == 0 then n else f (i - 1) m (n + m); fib = n: f n 1 1; in fib 0"
==>
1

# fibonacci 1
"let f = i: n: m: if i == 0 then n else f (i - 1) m (n + m); fib = n: f n 1 1; in fib 1"
==>
1

# fibonacci 2
"let f = i: n: m: if i == 0 then n else f (i - 1) m (n + m); fib = n: f n 1 1; in fib 2"
==>
2

# fibonacci 9
"let f = i: n: m: if i == 0 then n else f (i - 1) m (n + m); fib = n: f n 1 1; in fib 9"
==>
55

# fibonacci 99. bigint vs integer overflow. original Nix result: 3736710778780434371
"let f = i: n: m: if i == 0 then n else f (i - 1) m (n + m); fib = n: f n 1 1; in fib 99"
==>
354224848179261915075

# fibonacci 999. bigint vs integer overflow. original Nix result: 817770325994397771
"let f = i: n: m: if i == 0 then n else f (i - 1) m (n + m); fib = n: f n 1 1; in fib 999"
==>
43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875

# SKIP fibonacci 9999 = Maximum call stack size exceeded
"let f = i: n: m: if i == 0 then n else f (i - 1) m (n + m); fib = n: f n 1 1; in fib 9999"
==>
TODO

# call lambda with formals
"({x}:x) {x=1;}"
==>
1

# call lambda with formals
"({x,...}:x) {x=1;y=2;}"
==>
1

# call lambda with formals: extra formal
"({x}:x) {x=1;y=2;}"
==>
ERROR EvalError function at (string)+1 called with unexpected argument 'y'

# call lambda with formals: missing formal
"({x,y}:x) {x=1;}"
==>
ERROR EvalError function at (string)+1 called without required argument 'y'

# call lambda with formals: type error
"({x}:x) 1"
==>
ERROR EvalError value is an integer while a set was expected

# call lambda with formals: type error
"({x}:x) \"\""
==>
ERROR EvalError value is a string while a set was expected

# call lambda with formals: left binding
"(args@{...}: args) {a=1;}"
==>
{"a":1}

# call lambda with formals: right binding
"({...}@args: args) {a=1;}"
==>
{"a":1}

# call lambda with formals: syntax error
"(args@{...}@args: args) {a=1;}"
==>
ERROR SyntaxError unexpected invalid token

# default arguments
"let f = { a ? 1, b ? 2 }: a + b; in f {}"
==>
3

# has attr: true
"{a=1;}?a"
==>
true

# has attr: false
"{a=1;}?z"
==>
false

# has attr: type error
"1?z"
==>
false

# has attr: type error nested
"{a=1;}?a.z"
==>
false
