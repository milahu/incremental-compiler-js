# empty
""
==>
undefined

# whitespace
" \t\n"
==>
undefined

# null
"null"
==>
null

# bool
"true"
==>
true

# bool
"false"
==>
false

# int
"1"
==>
1

# float
"1.0"
==>
1.0

# int + float -> float
"1+1.0"
==>
2.0

# float precision
"0.1+0.2"
==>
0.3

# float precision
"0.123456789"
==>
0.123457

# neg
"-1"
==>
-1

# add
"1+1"
==>
2

# sub
"1-1"
==>
0

# empty set
"{}"
==>
{}

# empty rec set
"rec {}"
==>
{}

# set
"{a=1;}"
==>
{"a":1}

# rec set
"rec {a=1;}"
==>
{"a":1}

# rec set
"rec {a=1;b=a;}"
==>
{"a":1,"b":1}

# set error
"{a=1;b=a;}"
==>
ERROR EvalError undefined variable 'a'

# set select
"{a=1;}.a"
==>
1

# set select nested
"{a={b=2;};}.a.b"
==>
2

# set select key error
"{a=1;}.z"
==>
ERROR EvalError TODO

# rec set select
"rec {a=1;b=a;}.b"
==>
1

# let
"let a=1; in a"
==>
1

# let nested
"let a={b=2;}; in a.b"
==>
2

# call null
"null 2"
==>
ERROR EvalError attempt to call something which is not a function but null

# call bool true
"true 2"
==>
ERROR EvalError attempt to call something which is not a function but a Boolean

# call bool false
"false 2"
==>
ERROR EvalError attempt to call something which is not a function but a Boolean

# call list
"[] 2"
==>
ERROR EvalError attempt to call something which is not a function but a list

# call set
"{} 2"
==>
ERROR EvalError attempt to call something which is not a function but a set

# call string 1
"\"\" 2"
==>
ERROR EvalError attempt to call something which is not a function but a string

# SKIP call string 2
"'''' 2"
==>
ERROR EvalError attempt to call something which is not a function but a string

# call integer
"1 2"
==>
ERROR EvalError attempt to call something which is not a function but an integer

# call float
"1.1 2"
==>
ERROR EvalError attempt to call something which is not a function but a float

# call primop add
"__add 1 2"
==>
3

# call primop sub
"__sub 1 2"
==>
-1

# call primop mul
"__mul 1 2"
==>
2

# call primop div int int
"__div 1 2"
==>
0

# call primop div float int
"__div 1.0 2"
==>
0.5

# call primop div int float
"__div 1 2.0"
==>
0.5

# empty list
"[]"
==>
[]

# list
"[ 1 2 ]"
==>
[1,2]

# call primop head
"__head [ 1 2 ]"
==>
1

# call primop head empty
"__head [ ]"
==>
ERROR EvalError list index 0 is out of bounds

# call primop tail
"__tail [ 1 2 ]"
==>
2

# call primop tail empty
"__tail [ ]"
==>
ERROR EvalError 'tail' called on an empty list

# call primop elemAt
"__elemAt [ 1 2 ] 0"
==>
1

# call primop elemAt error 1 TODO implement parens
"__elemAt [ 1 2 ] (-1)"
==>
ERROR EvalError list index -1 is out of bounds

# call primop elemAt error 2
"__elemAt [ 1 2 ] 2"
==>
ERROR EvalError list index 2 is out of bounds

# add mul
"2+3*4"
==>
14

# parens add mul
"(2+3)*4"
==>
20

# path not div
"1/2"
==>
"/home/user/1/2"

# call not div
"1 /2"
==>
ERROR EvalError attempt to call something which is not a function but an integer

# div int int
"1/ 2"
==>
0

# div float int
"1.0/ 2"
==>
0.5

# typeof int
"__typeOf 1"
==>
"int"

# typeof float
"__typeOf 1.0"
==>
"float"

# typeof true
"__typeOf true"
==>
"bool"

# typeof false
"__typeOf false"
==>
"bool"

# typeof null
"__typeOf null"
==>
"null"

# typeof list
"__typeOf []"
==>
"list"

# typeof set
"__typeOf {}"
==>
"set"

# typeof string 1
"__typeOf \"\""
==>
"string"

# SKIP typeof string 2
"__typeOf ''''"
==>
"string"

# syntax error ~
"~"
==>
ERROR SyntaxError unexpected invalid token

# eval error undefined variable
"x"
==>
ERROR EvalError undefined variable 'x'

# neg bool
"!true"
==>
false

# neg neg bool
"!!true"
==>
true

# equal
"1==1"
==>
true

# not equal
"1!=2"
==>
true

# if
"if (!true) then 1 else 2"
==>
2

# lambda
"x: x"
==>
TODO

# call lambda
"(x: x) 1"
==>
1

# call lambda
"(x: y: x + y) 1 2"
==>
TODO

# let lambda call
"let f=x: 2*x; in f 3"
==>
TODO

# let lambda call nested
"let f = a: b: (a+b); in f 1 2"
==>
TODO

# lambda multi arg
"let f = x: y: z: x; in f 1 2 3"
==>
TODO

# lambda recursive call
"let f = x: if x > 0 then f (x - 1) else x; in f 1"
==>
TODO

# lambda nested call
"let f = x: y: (g 1 x) + y; g = x: y: x + y; in f 1 1"
==>
TODO

# fibonacci 0
"let f = i: n: m: if i == 0 then n else f (i - 1) m (n + m); fib = n: f n 1 1; in fib 0"
==>
TODO

# fibonacci 1
"let f = i: n: m: if i == 0 then n else f (i - 1) m (n + m); fib = n: f n 1 1; in fib 1"
==>
TODO

# fibonacci 2
"let f = i: n: m: if i == 0 then n else f (i - 1) m (n + m); fib = n: f n 1 1; in fib 2"
==>
TODO

# fibonacci 9
"let f = i: n: m: if i == 0 then n else f (i - 1) m (n + m); fib = n: f n 1 1; in fib 9"
==>
TODO

# fibonacci 99. bigint vs integer overflow. original Nix result: 3736710778780434371
"let f = i: n: m: if i == 0 then n else f (i - 1) m (n + m); fib = n: f n 1 1; in fib 99"
==>
TODO

# fibonacci 999. bigint vs integer overflow. original Nix result: 817770325994397771
"let f = i: n: m: if i == 0 then n else f (i - 1) m (n + m); fib = n: f n 1 1; in fib 999"
==>
TODO

# SKIP fibonacci 9999 = Maximum call stack size exceeded
"let f = i: n: m: if i == 0 then n else f (i - 1) m (n + m); fib = n: f n 1 1; in fib 9999"
==>
TODO
